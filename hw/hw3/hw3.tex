\input{../common.tex}

\title{EE219C HW3: Model Checking}
\author{Vighnesh Iyer}
\date{}
\maketitle

\section{Interrupt Driven Program}
\begin{enumerate}[label=(\alph*)]
  \item {\color{blue} Describe the properties in the \texttt{Sys} module in English.
    Note the composition of \texttt{main} and \texttt{ISR} within the module \texttt{Sys} is incorrectly done (you will need to fix it later).}

    \begin{itemize}
      \item \verb|invariant main_ISR_mutex: (M_enable != I_enable);|

        Only the main module or the ISR module can be active at a given timestep.

      \item \verb|property[LTL] one_step_ISR_return: G(return_ISR ==> X(!return_ISR));|

        If \verb|return_ISR| is true in a given timestep, it should be false in the next timestep for any trace of the system.
        This should ensure that the ISR module can't be advanced through in less than 1 timestep.

      \item \verb|property[LTL] main_after_ISR: G((I_enable && X(M_enable)) ==> return_ISR);|

        If on a particular timestep \verb|I_enable| is true and on the next time step \verb|M_enable| will be true, then \verb|return_ISR| should also be true on this timestep.

      \item \verb|property[LTL] ISR_after_main: G((M_enable && X(I_enable)) ==> (assert_intr));|

        The 'dual' of the previous property: if we are in the main module execution, and we are going to move into the ISR module next, the interrupt from the environment must also have been asserted right now.
    \end{itemize}

  \item {\color{blue} Run the file and interpret results.}

    The invariant passes a 20 cycle unrolling because \verb|mode| isn't being updated, and \verb|M_enable| and \verb|I_enable| are mutually exclusive conditions.

    The latter 2 LTL properties fail to check because \verb|mode| is being set arbitrarily and the counter-example traces contain transitions between the main and ISR modules that don't match the havoc behavior of \verb|mode| being arbitrarily set by the solver.

  \item {\color{blue}Fix to correctly compose main and ISR in \verb|Sys|, and eliminate the above CEXs. Change \verb|update_mode|.}

    \begin{minted}{text}
procedure update_mode() modifies mode; {
  case
    mode == main_t: {
      if (assert_intr) {
        mode = ISR_t;
      } else {
        mode = main_t;
      }
    }
    mode == ISR_t: {
      if (return_ISR) {
        mode = main_t;
      } else {
        mode = ISR_t;
      }
    }
  esac
}
    \end{minted}

    Now all the assertions pass.

  \item {\color{blue} Correctly compose \verb|Sys| and \verb|Env| (should it be async composition with interleaving semantics?). Explain why the \verb|consec_main_pc_values| property may fail when the composition is corrected.}

    I modified the \verb|init| and \verb|next| blocks as such:

    \begin{minted}{text}
init { havoc turn; }

next {
  if (turn) {
    next (Sys_i);
  } else {
    next (Env_i);
  }
  if (assert_intr) {
    turn' = true;
  } else {
    havoc turn;
  }
}
    \end{minted}

    I don't think it's acceptable for \verb|Sys| and \verb|Env| to be composed with async composition since once \verb|Env| raises the interrupt line, it is required that \verb|Sys| executes next to properly receive and interrupt. I think the decision as to which module to execute should be arbitrary, except with this one constraint.

    With this modification the \verb|consec_main_pc_values| property fails because the solver makes \verb|turn| false all the time and prevents forward movement in \verb|Sys| which causes the property to fail in limited time.
\end{enumerate}

\section{Smart Intersection}
\begin{enumerate}[label=(\alph*)]
  \item {\color{blue}Construct the \verb|no_collision| invariant.}

    \begin{minted}[breaklines]{text}
invariant no_collision: (car1_pos != car2_pos) && (car2_pos != car3_pos) && (car1_pos != car3_pos);
    \end{minted}

  \item {\color{blue}Define the \verb|can_move| procedure to determine which car can move}

    This was a lot harder than I expected. I first tried to incorporate the next potential positions of each car and asserted that cars can only move if there are no 'conflicts' but this was hard to encode correctly as setting \verb|move_p1| relied on knowing what \verb|move_p2,p3| were \textit{going} to be set to.

    I then tried to enforce a car movement ordering like this:
    \begin{minted}[breaklines]{text}
move_p1 = (!at_sink(c1) && at_source(c2) && at_source(c3)) || (at_sink(c1) && at_sink(c2) && at_sink(c3));
move_p2 = (at_sink(c1) && !at_sink(c2) && at_source(c3)) || (at_source(c1) && at_sink(c2) && at_sink(c3));
move_p3 = (at_sink(c1) && at_sink(c2) && !at_sink(c3)) || (at_source(c1) && at_source(c2) && at_sink(c3));
    \end{minted}
    but this too had a counterexample where car1 lands in a sink, then car2 moves to that same sink before car1 had a chance to respawn.

    So my final working code implements car1, car2, car3 ordering where each car must start from a source, finish its turn in the intersection, land in a sink and then respawn, before the subsequent car is allowed to move.

    \begin{minted}[breaklines]{text}
type turn_t = enum { move, respawn };
var turn1, turn2, turn3 : boolean;
var turn1_status, turn2_status, turn3_status: turn_t;
call (move1', move2', move3', turn1', turn2', turn3', turn1_status', turn2_status', turn3_status') = can_move(car1_pos, car2_pos, car3_pos, turn1, turn2, turn3, turn1_status, turn2_status, turn3_status);

procedure can_move(c1 : pos_t, c2 : pos_t, c3 : pos_t,
turn1: boolean, turn2: boolean, turn3: boolean,
turn1_status: turn_t, turn2_status: turn_t, turn3_status: turn_t)
  returns (move_p1 : boolean, move_p2 : boolean, move_p3 : boolean,
  turn1_nxt: boolean, turn2_nxt: boolean, turn3_nxt: boolean,
  turn1_status_nxt: turn_t, turn2_status_nxt: turn_t, turn3_status_nxt: turn_t)
{
    if (turn1) {
      move_p1 = true; move_p2 = false; move_p3 = false;
    }
    if (turn2) {
      move_p1 = false; move_p2 = true; move_p3 = false;
    }
    if (turn3) {
      move_p1 = false; move_p2 = false; move_p3 = true;
    }
    if (at_sink(c1)) {
      turn1_status_nxt = respawn;
    } else {
      turn1_status_nxt = move;
    }
    if (at_sink(c2)) {
      turn2_status_nxt = respawn;
    } else {
      turn2_status_nxt = move;
    }
    if (at_sink(c3)) {
      turn3_status_nxt = respawn;
    } else {
      turn3_status_nxt = move;
    }

    turn1_nxt = turn1; turn2_nxt = turn2; turn3_nxt = turn3;
    if (turn1_status_nxt == respawn) {
      turn1_nxt = false; turn2_nxt = true; turn3_nxt = false;
    }
    if (turn2_status_nxt == respawn) {
      turn1_nxt = false; turn2_nxt = false; turn3_nxt = true;
    }
    if (turn3_status_nxt == respawn) {
      turn1_nxt = true; turn2_nxt = false; turn3_nxt = false;
    }
}
    \end{minted}

    This finally worked and passed a 16 cycle BMC.

  \item {\color{blue}Define the \verb|bounded_exit| invariant and verify it for 16 cycles with BMC}

    In the worst case, each car takes 6 cycles to move from source to sink and then respawns at a new source. So I expect the bound on \verb|wait_cnt| to be 18.

    \begin{minted}{text}
invariant bounded_exit: (wait_cnt1 < 18) && (wait_cnt2 < 18) && (wait_cnt3 < 18);
property[LTL] bounded_1: G(F(wait_cnt1 == 0));
property[LTL] bounded_2: G(F(wait_cnt2 == 0));
property[LTL] bounded_3: G(F(wait_cnt3 == 0));
    \end{minted}

    I extended the BMC to 20 cycles of unrolling and these invariants and properties held.

  \item {\color{blue}Copy over to the induction file and prove the properties with induction for unbounded time. Add strenghtening invariants as necessary.}

    Wow, this was harder than expected. The solver needs you to state all the invariants very explicitly. So far, this is what I have:

    \begin{minted}[breaklines]{text}
invariant only_one_moves: (move1 && !move2 && !move3) || (!move1 && move2 && !move3) || (!move1 && !move2 && move3);
invariant only_one_turn: (turn1 && !turn2 && !turn3) || (!turn1 && turn2 && !turn3) || (!turn1 && !turn2 && turn3);
invariant at_least_one_moves: !(!turn1 && !turn2 && !turn3);
invariant turn_is_move: (move1 && turn1) || (move2 && turn2) || (move3 && turn3);
invariant valid_steps_all: valid_steps(steps1) && valid_steps(steps2) && valid_steps(steps3);
invariant valid_steps_at_sink: (steps1 == -1 ==> at_sink(car1_pos)) && (steps2 == -1 ==> at_sink(car2_pos)) && (steps3 == -1 ==> at_sink(car3_pos));
invariant valid_steps_src: (at_source(car1_pos) ==> valid_steps_at_src(steps1)) && (at_source(car2_pos) ==> valid_steps_at_src(steps2)) && (at_source(car3_pos) ==> valid_steps_at_src(steps3));
    \end{minted}
\end{enumerate}

\section{Linear Tempotal Logic}
\begin{enumerate}[label=(\alph*)]
  \item {\color{blue}Labeled transition system that encodes the dynamics of the puzzle}

    Let the state variables of the system $S = \{g, w, c\}$, where $g \in \{G_L, G_R, G_B\}$, $w \in \{W_L, W_R, W_B\}$, $c \in \{C_L, C_R, C_B\}$, where $g, w, c$ represent the locations of the goat, wolf, and cabbage on the left or right river banks, or on the boat.

    The initial state $S_0 = \{(G_L, W_L, C_L)\}$ puts the goat, wolf, and cabbage on the left bank.

    The transition function $\delta((g1,w1,c1), (g2,w2,c2))$ is true if only one of the state variables changes state and false otherwise. It can also be true if a boat swap is performed (i.e. $(G_B, W_L, C_L) \rightarrow (G_L, W_B, C_L)$) is permitted where the goat and wolf were swapped on the boat.

    The labeling function $L(g, w, c)$ emits $I$ (for illegal) if the state has the goat and cabbage on the same bank (without the wolf) or if the state has the wolf and goat on the same side (without the cabbage). Label the state $(G_R, W_R, C_R)$ with $G$ (for goal).

  \item {\color{blue}LTL formula which encodes the task and the constraints on the goat/cabbage/wolf}

    % no illegal states, only 1 thing on the boat

    The task can be encoded as $F(G)$ and the constraint encoded as $G(!I)$. The final LTL formula: $\phi = F(G) \land G(!I)$

  \item {\color{blue}Give a strategy to solve the river crossing puzzle}

    \begin{enumerate}
      \item Move the goat to the right bank and return \\
        - $(G_L, W_L, C_L) \rightarrow (G_B, W_L, C_L) \rightarrow (G_R, W_L, C_L)$
      \item Then move the cabbage to the right bank, and bring the goat back to the left bank
        - $(G_R, W_L, C_L) \rightarrow (G_R, W_L, C_B) \rightarrow (G_B$
      \item Move the wolf to the right bank and return
      \item Move the goat to the right bank
    \end{enumerate}


  \item {\color{blue}Encode the transition system and strategy as a Spin model}

  \item {\color{blue}Use Spin to prove the strategy and the world model satisfies the LTL formula from (b)}
\end{enumerate}
\end{document}
